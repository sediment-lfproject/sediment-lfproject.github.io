<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" class="js video maskImage placeholder" data-redeviation-bs-uid="108304"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">
  <meta name="author" content="SEDIMENT.">
  <title>/policies/technical/coding-style.html</title>
  <style>
      </style>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">

<link rel="canonical" href="https://www.opensslX.org/">
<link rel="icon" href="https://www.opensslX.org/favicon.ico">

<script src="./sediment_coding-style_files/modernizr-2.0.js.download"></script>
<script src="./sediment_coding-style_files/jquery-3.5.1.min.js.download"></script>
<script>!window.jQuery && document.write(unescape('%3Cscript src="./inc/libs/jquery-3.5.1.min.js"%3E%3C/script%3E'))</script>
<script type="text/javascript" src="./sediment_coding-style_files/octopress.js.download"></script>

<link rel="stylesheet" type="text/css" href="../../styles.css">

<style class="redeviation-bs-style" data-name="content">/*! (c) Philipp König under GPL-3.0 */
body>div#redeviation-bs-indicator>div{opacity:0;pointer-events:none}body>#redeviation-bs-sidebar.redeviation-bs-visible,body>#redeviation-bs-overlay.redeviation-bs-visible{opacity:1;pointer-events:auto}body.redeviation-bs-noscroll{overflow:hidden !important}body>div#redeviation-bs-indicator>div{position:absolute;transform:translate3d(-24px, 0, 0);top:0;left:0;width:24px !important;height:100%;background:rgba(0,0,0,0.5);border-radius:0 10px 10px 0;transition:opacity 0.3s, transform 0.3s;z-index:2}body>div#redeviation-bs-indicator>div>span{-webkit-mask:no-repeat center/24px;-webkit-mask-image:url(chrome-extension://jdbnofccmhefkmjbkkdkfiicjkgofkdh/img/icon-bookmark.svg);background-color:#ffffff;position:absolute;display:block;top:0;left:0;width:100%;height:100%}body>div#redeviation-bs-indicator[data-pos='right']{left:auto;right:0}body>div#redeviation-bs-indicator[data-pos='right']>div{transform:translate3d(24px, 0, 0);left:auto;right:0;border-radius:10px 0 0 10px}body>div#redeviation-bs-indicator.redeviation-bs-fullHeight>div{border-radius:0}body>div#redeviation-bs-indicator.redeviation-bs-hover>div{transform:translate3d(0, 0, 0);opacity:1}body>div#redeviation-bs-indicator[data-pos='left'].redeviation-bs-has-lsb{height:100% !important;top:0 !important}body>div#redeviation-bs-indicator[data-pos='left'].redeviation-bs-has-lsb>div{background:transparent}body>div#redeviation-bs-indicator[data-pos='left'].redeviation-bs-has-lsb>div>span{-webkit-mask-position-y:20px}body>#redeviation-bs-sidebar{width:350px;max-width:none;height:0;z-index:2147483646;background-color:rgba(255,255,255,0.8) !important;color-scheme:normal !important;speak:none;border:none;display:block !important;transform:translate3d(-350px, 0, 0);transition:width 0s 0.3s, height 0s 0.3s, opacity 0.3s, transform 0.3s}body>#redeviation-bs-sidebar[data-pos='right']{left:auto;right:0;transform:translate3d(350px, 0, 0)}body>#redeviation-bs-sidebar.redeviation-bs-visible{width:calc(100% + 350px);height:100%;transform:translate3d(0, 0, 0);transition:opacity 0.3s, transform 0.3s}body>#redeviation-bs-sidebar.redeviation-bs-hideMask{background:none !important}body>#redeviation-bs-sidebar.redeviation-bs-hideMask:not(.redeviation-bs-hover){width:calc(350px + 50px)}body>#redeviation-bs-overlay{width:100%;max-width:none;height:100%;z-index:2147483647;border:none;speak:none;background:rgba(0,0,0,0.5) !important;transition:opacity 0.3s}
</style></head>
<header>
    <a href="index.html">
        <h1>SEDIMENT</h1>
    </a>
    <nav>
        <ul>
            <li><a href="../../docs.html"><b>docs</b></a></li>
            <li><a href="../../community.html">community</a></li>
            <li><a href="../../charter.html">charter</a></li>
            <li><a class="button" href="https://github.com/sediment-lfproject"><img class="github-logo"
                        src="../../github-mark-white.svg">code</a></li>
        </ul>
    </nav>
</header>

<main class="main">

<section>
<div id="main">
    <div id="content">
        <div class="blog-index">
            <article>
<h2 id="sediment-coding-style">SEDIMENT coding style</h2>
<p>This document describes the coding style for the SEDIMENT project. It is derived from the <a href="https://www.openssl.org/policies/technical/coding-style.html" title="OpenSSL Coding Style">OpenSSL coding style</a>.</p>
<p>This guide is not distributed as part of SEDIMENT itself. 
<p>Coding style is all about readability and maintainability using commonly available tools. </p>
<h3 id="chapter-1-indentation">Chapter 1: Indentation</h3>
<p>Indentation is four space characters. Do not use the tab character.</p>
<p>Pre-processor directives does not use indentations:</p>

    </section>
<section>

    <pre><code>
        #if
        #define
        #else
        #define
        #endif
    </code></pre>

<h3 id="chapter-2-breaking-long-lines-and-strings">Chapter 2: Breaking long lines and strings</h3>
<p>Don’t put multiple statements, or assignments, on a single line.</p>
    
    <pre><code>
        if (condition) do_this();
        do_something_everytime();
    </code></pre>

<p>The limit on the length of lines is <em>120</em> columns. Statements longer than <em>120</em> columns must be broken into sensible chunks, unless exceeding <em>120</em> columns significantly increases readability and does not hide information. Descendants are always substantially shorter than the parent and are placed substantially to the right. The same applies to function headers with a long argument list. Never break user-visible strings, however, because that breaks the ability to grep for them.</p>

<h3 id="chapter-3-placing-braces-and-spaces">Chapter 3: Placing Braces and Spaces</h3>
<p>The other issue that always comes up in C styling is the placement of braces. Unlike the indent size, there are few technical reasons to choose one placement strategy over the other, but the preferred way, following Kernighan and Ritchie, is to put the opening brace last on the line, and the closing brace first:</p>
   
    <pre><code>
        if (x is true) {
            we do y
        }
    </code></pre>

<p>This applies to all non-function statement blocks (<code>if</code>, <code>switch</code>, <code>for</code>, <code>while</code>, <code>do</code>):</p>
    <pre><code>
        switch (suffix) {
            case 'G':
            case 'g':
                mem <<= 30;
                break;
            case 'M':
            case 'm':
                mem <<= 20;
                break;
            case 'K':
            case 'k':
                mem <<= 10;
                /* fall through */
            default:
                break;
            }
        }
    </code></pre>

<p>Note, from the above example, that the way to indent a switch statement is to align the switch and its subordinate case labels in the same column instead of <em>double-indenting</em> the case bodies.</p>
<p>There is one special case, however. Functions have the opening brace at the beginning of the next line:</p>
    <pre><code>
        int function(int x)
        {
            body of function
        }
    </code></pre>

<p>Note that the closing brace is empty on a line of its own, <strong>except</strong> in the cases where it is followed by a continuation of the same statement, such as a <code>while</code> in a do-statement, like this:</p>
    <pre><code>
        do {
            ...
        } while (condition);
    </code></pre>

<p>An <code>else</code> in an if-statement should start on a new line.</p>
    <pre><code>
        if (x == y) {
            ...
        }
        else if (x > y) {
            ...
        } 
        else {
            ...
        }
    </code></pre>

<p>Do not unnecessarily use braces around a single statement:</p>
    <pre><code>
        if (condition)
        action();
    </code></pre>

<p>and</p>
    <pre><code>
        if (condition)
            do_this();
        else
            do_that();
    </code></pre>

<p>If one of the branches is a compound statement, then use braces on both parts:</p>
    <pre><code>
        if (condition) {
            do_this();
            do_that();
        } 
        else {
            otherwise();
        }
    </code></pre>

<p>Nested compound statements should often have braces for clarity, particularly to avoid the dangling-else problem:</p>
    <pre><code>
        if (condition) {
            do_this();
            if (anothertest)
                do_that();
        } 
        else {
            otherwise();
        }
    </code></pre>

<h4 id="chapter-3.1-spaces">Chapter 3.1: Spaces</h4>
<p>SEDIMENT style for use of spaces depends (mostly) on whether the name is a function or keyword. Use a space after most keywords:</p>
    <pre><code> 
        if, switch, case, for, do, while, return
    </code></pre>

<p>Do not use a space after <code>sizeof</code>, <code>typeof</code>, <code>alignof</code>, or <code>__attribute__</code>. They look somewhat like functions and should have parentheses in SEDIMENT, although they are not required by the language. For <code>sizeof</code>, use a variable when at all possible, to ensure that type changes are properly reflected:</p>
    <pre><code> 
        SOMETYPE *p = malloc(sizeof(*p) * num_of_elements);
    </code></pre>

<p>Do not add spaces around the inside of parenthesized expressions. This example is wrong:</p>
    <pre><code> 
        s = sizeof( struct file );
    </code></pre>

<p>When declaring pointer data or a function that returns a pointer type, the asterisk goes next to the data or function name, and not the type:</p>
    <pre><code> 
        char *openssl_banner;
        unsigned long long memparse(char *ptr, char **retptr);
        char *match_strdup(substring_t *s);
    </code></pre>

<p>Use one space on either side of binary and ternary operators, such as this partial list:</p>
    <pre><code>
        =  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  : +=
    </code></pre>

<p>Put a space after commas and after semicolons in <code>for</code> statements, but not in <code>for (;;)</code>.</p>
<p>Do not put a space after unary operators:</p>
    <pre><code>
        &  *  +  -  ~  !  defined
    </code></pre>

<p>Do not put a space before the postfix increment and decrement unary operators or after the prefix increment and decrement unary operators:</p>
    <pre><code>
        foo++
        --bar
    </code></pre>

<p>Do not put a space around the <code>.</code> and <code>-&gt;</code> structure member operators:</p>
    <pre><code>
        foo.bar
        foo->bar
    </code></pre>

<p>Do not use multiple consecutive spaces except in comments, for indentation, and for multi-line alignment of definitions, e.g.:</p>
    <pre><code>
        #define FOO_INVALID  -1   /* invalid or inconsistent arguments */
        #define FOO_INTERNAL 0    /* Internal error, most likely malloc */
        #define FOO_OK       1    /* success */
        #define FOO_GREAT    100  /* some specific outcome */
    </code></pre>

<p>Do not leave trailing whitespace at the ends of lines. Some editors with <em>smart</em> indentation will insert whitespace at the beginning of new lines as appropriate, so you can start typing the next line of code right away. But they may not remove that whitespace if you leave a blank line, however, and you end up with lines containing trailing, or nothing but, whitespace.</p>
<p>Git will warn you about patches that introduce trailing whitespace, and can optionally strip the trailing whitespace; however, if applying a series of patches, this may make later patches in the series fail by changing their context lines.</p>
<p>Avoid empty lines at the beginning or at the end of a file.</p>
<p>Avoid multiple empty lines in a row.</p><br>

<h3 id="chapter-4-naming">Chapter 4: Naming</h3>
<p>Local variable names should be short, and to the point. If you have some random integer loop counter, it should probably be called <code>i</code> or <code>j</code>.</p>
<p>Avoid single-letter names when they can be visually confusing, such as <code>I</code> and <code>O</code>. Avoid other single-letter names unless they are telling in the given context. For instance, <code>m</code> for modulus and <code>s</code> for SSL pointers are fine.</p>
<p>Use simple variable names like <code>tmp</code> and <code>name</code> as long as they are non-ambiguous in the given context.</p>
<p>If you are afraid that someone might mix up your local variable names, perhaps the function is too long; see the <a href="https://www.opensslX.org/policies/technical/coding-style.html#chapter-5-functions">chapter on functions</a>.</p>
<p>Global variables (to be used only if you REALLY need them) need to have descriptive names, as do global functions. If you have a function that counts the number of active users, you should call that <em>count_active_users()</em> or similar, you should NOT call it <em>cntusr()</em>.</p>

<p>Do not encode the type into a name (so-called Hungarian notation, e.g., <code>int iAge</code>).</p>
<p>Align names to terms and wording used in standards and RFCs.</p>
<p>Make sure that names do not contain spelling errors.</p>

<br>
<h3 id="chapter-5-functions">Chapter 5: Functions</h3>
<p>Ideally, functions should be short and sweet, and do just one thing. A rule of thumb is that they should fit on one or two screenfuls of text (25 lines as we all know), and do one thing and do that well.</p>
<p>The maximum length of a function is often inversely proportional to the complexity and indentation level of that function. So, if you have a conceptually simple function that is just one long (but simple) switch statement, where you have to do lots of small things for a lot of different cases, it’s okay to have a longer function.</p>
<p>If you have a complex function, however, consider using helper functions with descriptive names. You can ask the compiler to in-line them if you think it’s performance-critical, and it will probably do a better job of it than you would have done.</p>
<p>Another measure of complexity is the number of local variables. If there are more than five to 10, consider splitting it into smaller pieces. A human brain can generally easily keep track of about seven different things; anything more and it gets confused. Often things which are simple and clear now are much less obvious two weeks from now, or to someone else. An exception to this is the command-line applications which support many options.</p>
<p>In source files, separate functions with one blank line.</p>
<p>In function prototypes, include parameter names with their data types. Although this is not required by the C language, it is preferred in SEDIMENT because it is a simple way to add valuable information for the reader. The name in the prototype declaration should match the name in the function definition.</p>
<p>Separate local variable declarations and subsequent statements by an empty line.</p>
<p>Do not mix local variable declarations and statements.</p>

<br>
<h4 id="chapter-5.1-checking-function-arguments">Chapter 5.1: Checking function arguments</h4>
<p>A <em>public</em> function should verify that its arguments are sensible. This includes, but is not limited to, verifying that: - non-optional pointer arguments are not NULL and - numeric arguments are within expected ranges.</p>
<p>Where an argument is not sensible, an error should be returned.</p>

<br>
<h4 id="chapter-5.2-extending-existing-functions">Chapter 5.2: Extending existing functions</h4>
<p>From time to time it is necessary to extend an existing function. Typically this will mean adding additional arguments, but it may also include removal of some.</p>
<p>Where an extended function should be added the original function should be kept and a new version created with the same name and an <code>_ex</code> suffix. For example, the <code>RAND_bytes</code> function has an extended form called <code>RAND_bytes_ex</code>.</p>
<p>Where an extended version of a function already exists and a second extended version needs to be created then it should have an <code>_ex2</code> suffix, and so on for further extensions.</p>
<p>When an extended version of a function is created the order of existing parameters from the original function should be retained. However new parameters may be inserted at any point (they do not have to be at the end), and no longer required parameters may be removed.</p>

<br>
<h3 id="chapter-6-centralized-exiting-of-functions">Chapter 6: Centralized exiting of functions</h3>
<p>The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done. If there is no cleanup needed then just return directly. The rationale for this is as follows:</p>
<ul>
<li>Unconditional statements are easier to understand and follow</li>
<li>It can reduce excessive control structures and nesting</li>
<li>It avoids errors caused by failing to updated multiple exit points when the code is modified</li>
<li>It saves the compiler work to optimize redundant code away ;)</li>
</ul>
<p>For example:</p>
    <pre><code>
        int fun(int a)
        {
            int result = 0;
            char *buffer = OPENSSL_malloc(SIZE);
    
            if (buffer == NULL)
                return -1;
    
            if (condition1) {
                while (loop1) {
                    ...
                }
                result = 1;
                goto out;
            }
            ...
        out:
            OPENSSL_free(buffer);
            return result;
        }
    </code></pre>

<h3 id="chapter-7-commenting">Chapter 7: Commenting</h3>
<p>Place comments above or to the right of the code they refer to. Comments referring to the code line after should be indented equally to that code line.</p>
<p>Comments are good, but there is also a danger of over-commenting. NEVER try to explain HOW your code works in a comment. It is much better to write the code so that it is obvious, and it’s a waste of time to explain badly written code. You want your comments to tell WHAT your code does, not HOW.</p>
<p>The preferred style for long (multi-line) comments is:</p>
    <pre><code>
        /*
        * This is the preferred style for multi-line
        * comments in the SEDIMENT source code.
        * Please use it consistently.
        *
        * Description:  A column of asterisks on the left side,
        * with beginning and ending almost-blank lines.
        */
    </code></pre>

<p>It’s also important to comment data, whether they are basic types or derived types. To this end, use just one data declaration per line (no commas for multiple data declarations). This leaves you room for a small comment on each item, explaining its use.</p>

<br>
<h3 id="chapter-8-macros-and-enums">Chapter 8: Macros and Enums</h3>
<p>Names of macros defining constants and labels in enums are in uppercase:</p>
    <pre><code>
        #define CONSTANT 0x12345
    </code></pre>

<p>Enums are preferred when defining several related constants. Note, however, that enum arguments to public functions are not permitted.</p>
<p>Macro names should be in uppercase, but macros resembling functions may be written in lower case. Generally, inline functions are preferable to macros resembling functions.</p>
<p>Macros with multiple statements should be enclosed in a do - while block:</p>
    <pre><code>
        #define macrofun(a, b, c)   \
        do {                    \
            if (a == 5)         \
                do_this(b, c);  \
        } while (0)
    </code></pre>

<p>Do not write macros that affect control flow:</p>
    <pre><code>
        #define FOO(x)                 \
        do {                       \
            if (blah(x) < 0)       \
                return -EBUGGERED; \
        } while(0)
    </code></pre>

<p>Do not write macros that depend on having a local variable with a magic name:</p>
    <pre><code>
        #define FOO(val) bar(index, val)
    </code></pre>

<p>It is confusing to the reader and is prone to breakage from seemingly innocent changes.</p>
<p>Do not write macros that are l-values:</p>
    <pre><code>
        FOO(x) = y
    </code></pre>
<p>This will cause problems if, e.g., FOO becomes an inline function.</p>
<p>Be careful of precedence. Macros defining an expression must enclose the expression in parentheses unless the expression is a literal or a function application:</p>
    <pre><code>
        #define SOME_LITERAL 0x4000
        #define CONSTEXP (SOME_LITERAL | 3)
        #define CONSTFUN foo(0, CONSTEXP)
    </code></pre>

<p>Beware of similar issues with macros using parameters. Put parentheses around uses of macro arguments unless they are passed on as-is to a further macro or function. For example,</p>
    <pre><code>
        #define MACRO(a,b) ((a) * func(a, b))
    </code></pre>
<p>The <a href="https://gcc.gnu.org/onlinedocs/"" class="link" title="GCC online documentation">GNU cpp manual</a> deals with macros exhaustively.</p>

<br>
<h3 id="chapter-9-editor-modelines">Chapter 9: Editor modelines</h3>
<p>Some editors can interpret configuration information embedded in source files, indicated with special markers. For example, emacs interprets lines marked like this:</p>
    <pre><code>
        - mode: c -
    </code></pre>

<p>Or like this:</p>
    <pre><code>
        /*
        Local Variables:
        compile-command: "gcc -DMAGIC_DEBUG_FLAG foo.c"
        End:
        */
    </code></pre>

<p>Vim interprets markers that look like this:</p>
    <pre><code>
        /* vim:set sw=8 noet */
    </code></pre>

<p>Do not include any of these in source files. People have their own personal editor configurations, and your source files should not override them. This includes markers for indentation and mode configuration. People may use their own custom mode, or may have some other magic method for making indentation work correctly.</p>

<br>
<h3 id="chapter-10-expressions">Chapter 10: Expressions</h3>

<p>Avoid needless parentheses as far as reasonable. For example, do not write</p>
    <pre><code>
        if ((p == NULL) && (!f(((2 * x) + y) == (z++))))
    </code></pre>
<p>but</p>
    <pre><code>
        if (p == NULL && !f(2 * x + y == z++)).
    </code></pre>

<p>For clarity, always put parentheses when mixing the logical <code>&amp;&amp;</code> and <code>||</code> operators, mixing comparison operators like <code>&lt;=</code> and <code>==</code>, or mixing bitwise operators like <code>&amp;</code> and <code>|</code>. For example,</p>
    <pre><code>
        if ((a && b) || c)
        if ((a <= b) == ((c >= d) != (e < f)))
        x = (a & b) ^ (c | d)
    </code></pre>

<p>In comparisons with constants (including <code>NULL</code> and other constant macros) place the constant on the right-hand side of the comparison operator. For example,</p>
    <pre><code>
        while (i++ < 10 && p != NULL)
    </code></pre>

<p>Do not use implicit checks for numbers (not) being <code>0</code> or pointers (not) being <code>NULL</code>. For example, do not write</p>
    <pre><code>
        if (i)
        if (!(x & MASK))
        if (!strcmp(a, "FOO"))
        if (!(p = BN_new()))
    </code></pre>

<p>but do this instead:</p>
    <pre><code>
        if (i != 0)
        if ((x & MASK) == 0)
        if (strcmp(a, "FOO") == 0)
        if ((p = BN_new()) == NULL)
    </code></pre>

<p>Boolean values shall be used directly as usual, e.g.,</p>
    <pre><code>
        if (check(x) && !success(y))
    </code></pre>

<p>Note: Many functions can return <code>0</code> or a negative value on error and the Boolean forms need to be used with care.</p>
<p>If you need to break an expression into multiple lines, make the line break before an operator, not after. It is preferred that such a line break is made before as low priority an operator as possible. Examples:</p>
<ul>

<li><p>not this:</p>
    <pre><code>
        if (somewhat_long_function_name(foo) == 1 && a_long_variable_name
== 2)
    </code></pre>        

<p>but rather:</p>
    <pre><code>
        if (somewhat_long_function_name(foo) == 1
    && a_long_variable_name == 2)
    </code></pre>     

<li><p>This is, however, still ok:</p>
    <pre><code>
        if (this_thing->this_freakishly_super_long_name(somewhat_long_name, 3)
    == PRETTY_DARN_LONG_MACRO_NAME)
    </code></pre>   
</ul>

<p>When appearing at the beginning of a line, operators can, but do not have to, get an extra indentation (+ 4 characters). For example,</p>
    <pre><code>
        if (long_condition_expression_1
                && condition_expression_2) {
            statement_1;
            statement_2;
        }
    </code></pre>  
    
</section>
</main>
<footer role="contentinfo">
    <p>
        Please report problems with this website to webmaster at https://github.com/sediment-lfproject.
    </p>
    <p>
        Copyright © 2023, SEDIMENT Project Authors.
        All Rights Reserved.
    </p>
</footer>

<app-frame-108304 id="redeviation-bs-sidebar" class="notranslate" aria-hidden="true" data-theme="default" data-pos="left"></app-frame-108304><div id="redeviation-bs-indicator" data-theme="default" class="redeviation-bs-fullHeight" style="height: 100%; top: 0%;"></div></body></html>
</body>
</html>